

# Detecting Patterns in Tables Beta

# 检测表格中的模式

It is a common use case to search for a set of event patterns, especially in case of data streams. Flink comes with a [complex event processing (CEP) library](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/libs/cep.html) which allows for pattern detection in event streams. Furthermore, Flink’s SQL API provides a relational way of expressing queries with a large set of built-in functions and rule-based optimizations that can be used out of the box.

搜索一组事件模式是一种常见的用例，尤其是在数据流的情况下。Flink 附带了一个[复杂事件处理(CEP)库](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/libs/cep.html)，允许在事件流中进行模式检测。此外，Flink 的 SQL AP I提供了一种表达查询的关系方式，该方法具有大量内置函数和基于规则的优化，可以直接使用。

In December 2016, the International Organization for Standardization (ISO) released a new version of the SQL standard which includes _Row Pattern Recognition in SQL_ ([ISO/IEC TR 19075-5:2016](https://standards.iso.org/ittf/PubliclyAvailableStandards/c065143_ISO_IEC_TR_19075-5_2016.zip)). It allows Flink to consolidate CEP and SQL API using the `MATCH_RECOGNIZE` clause for complex event processing in SQL.

2016年12月，国际标准化组织（ISO）发布了 SQL 标准的新版本，其中包括[_SQL 中的 Row 模式识别_]([ISO/IEC TR 19075-5:2016](https://standards.iso.org/ittf/PubliclyAvailableStandards/c065143_ISO_IEC_TR_19075-5_2016.zip))。它允许Flink使用 `MATCH_RECOGNIZE` 子句整合 CEP 和 SQL API，以便在 SQL 中进行复杂事件处理。



A `MATCH_RECOGNIZE` clause enables the following tasks:

`MATCH_RECOGNIZE` 子句启用以下任务：

*   Logically partition and order the data that is used with the `PARTITION BY` and `ORDER BY` clauses.
*   Define patterns of rows to seek using the `PATTERN` clause. These patterns use a syntax similar to that of regular expressions.
*   The logical components of the row pattern variables are specified in the `DEFINE` clause.
*   Define measures, which are expressions usable in other parts of the SQL query, in the `MEASURES` clause.

*   数据的逻辑分区和排序使用 `PARTITION BY` 和 `ORDER BY` 子句。
*   使用 `PATTERN` 子句定义要搜索的行的模式。这些模式使用类似于正则表达式的语法。
*   行模式变量的逻辑组件在 `DEFINE` 子句中指定。
*   在 `MEASURES` 子句中定义 measures，measures 是 SQL 查询的其他部分中可用的表达式。


The following example illustrates the syntax for basic pattern recognition:

以下示例说明了基本模式识别的语法：



```
SELECT T.aid, T.bid, T.cid
FROM MyTable
MATCH_RECOGNIZE (
  PARTITION BY userid
  ORDER BY proctime
  MEASURES
    A.id AS aid,
    B.id AS bid,
    C.id AS cid
  PATTERN (A B C)
  DEFINE
    A AS name = 'a',
    B AS name = 'b',
    C AS name = 'c'
) AS T
```



This page will explain each keyword in more detail and will illustrate more complex examples.

本文将更详细地解释每个关键字，并将说明更复杂的示例。

Attention Flink’s implementation of the `MATCH_RECOGNIZE` clause is a subset of the full standard. Only those features documented in the following sections are supported. Since the development is still in an early phase, please also take a look at the [known limitations](#known-limitations).

注意 Flink 对 `MATCH_RECOGNIZE` 子句的实现是完整标准的一个子集。仅支持以下记录的那些部分功能。由于开发仍处于早期阶段，请同时查看[known limitations](#known-limitations)。

## Introduction and Examples

## 介绍和实例

### Installation Guide

### 安装指南

The pattern recognition feature uses the Apache Flink’s CEP library internally. In order to be able to use the `MATCH_RECOGNIZE` clause, the library needs to be added as a dependency to your Maven project.

模式识别功能在内部使用 Apache Flink 的 CEP 库。为了能够使用 `MATCH_RECOGNIZE` 子句，需要将库添加为 Maven 项目的依赖项。



```
<dependency>
  <groupId>org.apache.flink</groupId>
  <artifactId>flink-cep_2.11</artifactId>
  <version>1.7.1</version>
</dependency>
```



Alternatively, you can also add the dependency to the cluster classpath (see the [dependency section](//ci.apache.org/projects/flink/flink-docs-release-1.7/projectsetup/dependencies.html) for more information).

或者，您也可以将依赖项添加到集群类路径（有关详细信息，请参阅[依赖项部分](//ci.apache.org/projects/flink/flink-docs-release-1.7/projectsetup/dependencies.html)）。

If you want to use the `MATCH_RECOGNIZE` clause in the [SQL Client](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/table/sqlClient.html), you don’t have to do anything as all the dependencies are included by default.

如果要在 SQL 客户端中使用 `MATCH_RECOGNIZE` 子句，则不必执行任何操作，因为默认情况下包含所有依赖项。

### SQL Semantics

### SQL 语义

Every `MATCH_RECOGNIZE` query consists of the following clauses:

每个 `MATCH_RECOGNIZE` 查询都包含以下子句：

*   [PARTITION BY](#partitioning) - defines the logical partitioning of the table; similar to a `GROUP BY` operation.
*   [ORDER BY](#order-of-events) - specifies how the incoming rows should be ordered; this is essential as patterns depend on an order.
*   [MEASURES](#define--measures) - defines output of the clause; similar to a `SELECT` clause.
*   [ONE ROW PER MATCH](#output-mode) - output mode which defines how many rows per match should be produced.
*   [AFTER MATCH SKIP](#after-match-strategy) - specifies where the next match should start; this is also a way to control how many distinct matches a single event can belong to.
*   [PATTERN](#defining-pattern) - allows constructing patterns that will be searched for using a _regular expression_-like syntax.
*   [DEFINE](#define--measures) - this section defines the conditions that the pattern variables must satisfy.

*   [PARTITION BY](#partitioning) - 定义表的逻辑分区; 类似于 `GROUP BY` 操作。
*   [ORDER BY](#order-of-events) - 指定如何排序传入的行; 这是必不可少的，因为模式取决于排序。
*   [MEASURES](#define--measures) - 定义子句的输出; 类似于 `SELECT` 子句。
*   [ONE ROW PER MATCH](#output-mode) - 输出模式，定义每个匹配应生成多少行。
*   [AFTER MATCH SKIP](#after-match-strategy) - 指定下一个匹配的开始位置; 这也是一种控制单个事件属于多少个不同匹配的方法。
*   [PATTERN](#defining-pattern) - 允许使用类似 _正则表达式_ 的语法构造将要搜索的模式。
*   [DEFINE](#define--measures) -  此部分定义（匹配）模式变量必须满足的条件。



Attention Currently, the `MATCH_RECOGNIZE` clause can only be applied to an [append table](dynamic_tables.html#update-and-append-queries). Furthermore, it always produces an append table as well.

注意，目前 `MATCH_RECOGNIZE` 子句只能应用于[追加表(append table)](dynamic_tables.html#update-and-append-queries)。此外，它总是生成一个追加表。

### Examples

### 例子

For our examples, we assume that a table `Ticker` has been registered. The table contains prices of stocks at a particular point in time.

对于我们的示例，我们假设已经注册了表格 `Ticker`。该表包含特定时间点的股票价格。

The table has a following schema:

该表具有以下 schema：



```
Ticker
     |-- symbol: String                           # symbol of the stock
     |-- price: Long                              # price of the stock
     |-- tax: Long                                # tax liability of the stock
     |-- rowtime: TimeIndicatorTypeInfo(rowtime)  # point in time when the change to those values happened
```



For simplification, we only consider the incoming data for a single stock `ACME`. A ticker could look similar to the following table where rows are continuously appended.

为简化起见，我们仅考虑单个股票 `ACME` 的输入数据。ticker看起来类似于下表，其中连续追加行。



```
symbol         rowtime         price    tax
======  ====================  ======= =======
'ACME'  '01-Apr-11 10:00:00'   12      1
'ACME'  '01-Apr-11 10:00:01'   17      2
'ACME'  '01-Apr-11 10:00:02'   19      1
'ACME'  '01-Apr-11 10:00:03'   21      3
'ACME'  '01-Apr-11 10:00:04'   25      2
'ACME'  '01-Apr-11 10:00:05'   18      1
'ACME'  '01-Apr-11 10:00:06'   15      1
'ACME'  '01-Apr-11 10:00:07'   14      2
'ACME'  '01-Apr-11 10:00:08'   24      2
'ACME'  '01-Apr-11 10:00:09'   25      2
'ACME'  '01-Apr-11 10:00:10'   19      1
```



The task is now to find periods of a constantly decreasing price of a single ticker. For this, one could write a query like:

现在的任务是找到单个股票价格不断下降的时期。为此，可以编写如下查询：



```
SELECT *
FROM Ticker
MATCH_RECOGNIZE (
    PARTITION BY symbol
    ORDER BY rowtime
    MEASURES
        START_ROW.rowtime AS start_tstamp,
        LAST(PRICE_DOWN.rowtime) AS bottom_tstamp,
        LAST(PRICE_UP.rowtime) AS end_tstamp
    ONE ROW PER MATCH
    AFTER MATCH SKIP TO LAST PRICE_UP
    PATTERN (START_ROW PRICE_DOWN+ PRICE_UP)
    DEFINE
        PRICE_DOWN AS
            (LAST(PRICE_DOWN.price, 1) IS NULL AND PRICE_DOWN.price < START_ROW.price) OR
                PRICE_DOWN.price < LAST(PRICE_DOWN.price, 1),
        PRICE_UP AS
            PRICE_UP.price > LAST(PRICE_DOWN.price, 1)
    ) MR;
```



The query partitions the `Ticker` table by the `symbol` column and orders it by the `rowtime` time attribute.

查询按 `symbol` 列对 `Ticker` 表进行分区，并按 `rowtime` 属性对其进行排序。

The `PATTERN` clause specifies that we are interested in a pattern with a starting event `START_ROW` that is followed by one or more `PRICE_DOWN` events and concluded with a `PRICE_UP` event. If such a pattern can be found, the next pattern match will be seeked at the last `PRICE_UP` event as indicated by the `AFTER MATCH SKIP TO LAST` clause.

`PATTERN` 子句指定模式，使用开始事件 `START_ROW`，该模式后跟一个或多个 `PRICE_DOWN` 事件，并以 `PRICE_UP` 事件结束。如果可以找到这样的模式，则将在最后的 `PRICE_UP` 事件中寻找下一个模式匹配，如 `AFTER MATCH SKIP TO LAST` 子句所示。

The `DEFINE` clause specifies the conditions that need to be met for a `PRICE_DOWN` and `PRICE_UP` event. Although the `START_ROW` pattern variable is not present it has an implicit condition that is evaluated always as `TRUE`.

`DEFINE` 子句需要指定条件满足 `PRICE_DOWN` 和 `PRICE_UP` 事件。虽然 `START_ROW` 模式变量不存在，但它具有一个隐式条件，该条件总是被评估为 `TRUE`。

A pattern variable `PRICE_DOWN` is defined as a row with a price that is smaller than the price of the last row that met the `PRICE_DOWN` condition. For the initial case or when there is no last row that met the `PRICE_DOWN` condition, the price of the row should be smaller than the price of the preceding row in the pattern (referenced by `START_ROW`).

模式变量 `PRICE_DOWN` 被定义为具有 price 的行，它小于最后一行的 price，最后一行的 price 满足 `PRICE_DOWN` 条件。对于初始情况或当没有满足 `PRICE_DOWN` 条件的最后一行时，行的 price 应该小于模式中前一行的价格（由 `START_ROW` 引用）。

A pattern variable `PRICE_UP` is defined as a row with a price that is larger than the price of the last row that met the `PRICE_DOWN` condition.

模式变量 `PRICE_UP` 定义为 `price` 行，它大于最后一行的 `price`，它满足 `PRICE_DOWN` 条件。

This query produces a summary row for each period in which the price of a stock was continuously decreasing.

此查询为每个期间生成一个汇总行，其中股票的价格不断下降。

The exact representation of the output rows is defined in the `MEASURES` part of the query. The number of output rows is defined by the `ONE ROW PER MATCH` output mode.

输出行的确切表示在查询的 `MEASURES` 部分中定义。输出行数由 `ONE ROW PER MATCH` 输出模式定义。



```
 symbol       start_tstamp       bottom_tstamp         end_tstamp
=========  ==================  ==================  ==================
ACME       01-APR-11 10:00:04  01-APR-11 10:00:07  01-APR-11 10:00:08
```



The resulting row describes a period of falling prices that started at `01-APR-11 10:00:04` and achieved the lowest price at `01-APR-11 10:00:07` that increased again at `01-APR-11 10:00:08`.

结果行描述了从 `01-APR-11 10:00:04` 开始的价格下跌期，并在 `01-APR-11 10:00:07` 达到最低价格，在 `01-APR-11 10:00：08` 再次上涨。


## Partitioning

## 分区

It is possible to look for patterns in partitioned data, e.g., trends for a single ticker or a particular user. This can be expressed using the `PARTITION BY` clause. The clause is similar to using `GROUP BY` for aggregations.

可以在分区数据中查找模式，例如，单个股票或特定用户的趋势。这可以使用 `PARTITION BY` 子句表示。该子句类似于使用 `GROUP BY` 进行聚合。

Attention It is highly advised to partition the incoming data because otherwise the `MATCH_RECOGNIZE` clause will be translated into a non-parallel operator to ensure global ordering.

注意,强烈建议对传入数据进行分区，否则 `MATCH_RECOGNIZE` 子句将被转换为非并行operator以确保全局排序。

## Order of Events

## 事件顺序

Apache Flink allows for searching for patterns based on time; either [processing time or event time](time_attributes.html).

Apache Flink 允许根据时间搜索模式; [处理时间或事件时间](time_attributes.html)。

In case of event time, the events are sorted before they are passed to the internal pattern state machine. As a consequence, the produced output will be correct regardless of the order in which rows are appended to the table. Instead, the pattern is evaluated in the order specified by the time contained in each row.

在事件时间的情况下，事件在传递到内部模式状态机(the internal pattern state machine)之前进行排序。因此，无论行追加到表的顺序如何，生成的输出都是正确的。按照每行中包含的时间指定的顺序的评估模式。

The `MATCH_RECOGNIZE` clause assumes a [time attribute](time_attributes.html) with ascending ordering as the first argument to `ORDER BY` clause.

`MATCH_RECOGNIZE` 子句假定时间属性具有升序排序作为 `ORDER BY` 子句的第一个参数。

For the example `Ticker` table, a definition like `ORDER BY rowtime ASC, price DESC` is valid but `ORDER BY price, rowtime` or `ORDER BY rowtime DESC, price ASC` is not.

对于示例 `Ticker` 表，定义如 `ORDER BY rowtime ASC, price DESC` 有效，但 `ORDER BY price, rowtime` 或 `ORDER BY rowtime DESC, price ASC` 无效


## Define & Measures

## Define 和 Measures

The `DEFINE` and `MEASURES` keywords have similar meanings to the `WHERE` and `SELECT` clauses in a simple SQL query.

`DEFINE` 和 `MEASURES` 关键字与简单 SQL 查询中的 `WHERE` 和 `SELECT` 子句具有相似的含义。

The `MEASURES` clause defines what will be included in the output of a matching pattern. It can project columns and define expressions for evaluation. The number of produced rows depends on the [output mode](#output-mode) setting.

`MEASURES` 子句定义将包含在匹配模式的输出中的内容。它可以投影列并定义表达式以进行评估。生成的行数取决于[输出模式](#output-mode)设置。

The `DEFINE` clause specifies conditions that rows have to fulfill in order to be classified to a corresponding [pattern variable](#defining-pattern). If a condition is not defined for a pattern variable, a default condition will be used which evaluates to `true` for every row.

`DEFINE` 子句指定行必须满足的条件才能被分类到相应的[模式变量](#defining-pattern)。如果没有为模式变量定义条件，则将使用默认条件，对于每一行，该条件的计算结果为 `true`。

For a more detailed explanation about expressions that can be used in those clauses, please have a look at the [event stream navigation](#pattern-navigation) section.

有关可在这些子句中使用的表达式的更详细说明，请查看[event stream navigation](#pattern-navigation)部分。

## Defining a Pattern

## 定义模式

The `MATCH_RECOGNIZE` clause allows users to search for patterns in event streams using a powerful and expressive syntax that is somewhat similar to the widespread regular expression syntax.

`MATCH_RECOGNIZE` 子句允许用户使用功能强大且富有表现力的语法搜索事件流中的模式，该语法与广泛使用的正则表达式语法类似。

Every pattern is constructed from basic building blocks, called _pattern variables_, to which operators (quantifiers and other modifiers) can be applied. The whole pattern must be enclosed in brackets.

每个模式都是由基本构建块构建的，称为 _模式变量(pattern variables)_，可以应用 operators（量词和其他修饰符）。整个模式必须括在括号中。

An example pattern could look like:

示例模式可能如下所示：



```
PATTERN (A B+ C* D)
```



One may use the following operators:

可以使用以下运算符：

*   _Concatenation_ - a pattern like `(A B)` means that the contiguity is strict between `A` and `B`. Therefore, there can be no rows that were not mapped to `A` or `B` in between.
*   _Concatenation_ - 像`(A B)`这样的模式意味着A和B之间的连续性是严格的。因此，不存在未映射到A或B之间的行。
*   _Quantifiers_ - modify the number of rows that can be mapped to the pattern variable.
*   _Quantifiers_ - 修改可以映射到模式变量的行数。
    *   `*` — _0_ or more rows
    *   `*` — _0_ 行或更多行
    *   `+` — _1_ or more rows
    *   `+` — _1_ 行或更多行
    *   `?` — _0_ or _1_ rows
    *   `?` — _0_ 或 _1_ 行
    *   `{ n }` — exactly _n_ rows (_n &gt; 0_)
    *   `{ n }` — 正好是 _n_ 行（_n &gt; 0_）
    *   `{ n, }` — _n_ or more rows (_n ≥ 0_)
    *   `{ n, }` — _n_ 行或更多行（_n ≥ 0_）
    *   `{ n, m }` — between _n_ and _m_ (inclusive) rows (_0 ≤ n ≤ m, 0 &lt; m_)
    *   `{ n, m }` — _n_ 和 _m_（含）行之间（_0≤n≤m，0 &lt; m_）
    *   `{ , m }` — between _0_ and _m_ (inclusive) rows (_m &gt; 0_)
    *   `{ , m }` — 介于 _0_ 和 _m_（含）行之间（_m &gt; 0_）

Attention Patterns that can potentially produce an empty match are not supported. Examples of such patterns are `PATTERN (A*)`, `PATTERN (A? B*)`, `PATTERN (A{0,} B{0,} C*)`, etc.

注意不支持可能产生空匹配的模式。这种模式的示例是 `PATTERN (A*)`，`PATTERN (A? B*)`，`PATTERN (A{0,} B{0,} C*)`等。

### Greedy & Reluctant Quantifiers

### Greedy 和 Reluctant 量词

Each quantifier can be either _greedy_ (default behavior) or _reluctant_. Greedy quantifiers try to match as many rows as possible while reluctant quantifiers try to match as few as possible.

每个量词可以是 _greedy（贪婪）_（默认行为）或 _reluctant（不情愿）_ 的。贪心量词（Greedy quantifiers）试图匹配尽可能多的行，而不情愿的量词试图尽可能少地匹配。

In order to illustrate the difference, one can view the following example with a query where a greedy quantifier is applied to the `B` variable:

为了说明差异，可以使用查询查看以下示例，其中将 Greedy（贪心）量词应用于 `B` 变量：



```
SELECT *
FROM Ticker
    MATCH_RECOGNIZE(
        PARTITION BY symbol
        ORDER BY rowtime
        MEASURES
            C.price AS lastPrice
        ONE ROW PER MATCH
        AFTER MATCH SKIP PAST LAST ROW
        PATTERN (A B* C)
        DEFINE
            A AS A.price > 10,
            B AS B.price < 15,
            C AS C.price > 12
    )
```



Given we have the following input:

鉴于我们有以下输入：



```
 symbol  tax   price          rowtime
======= ===== ======== =====================
 XYZ     1     10       2018-09-17 10:00:02
 XYZ     2     11       2018-09-17 10:00:03
 XYZ     1     12       2018-09-17 10:00:04
 XYZ     2     13       2018-09-17 10:00:05
 XYZ     1     14       2018-09-17 10:00:06
 XYZ     2     16       2018-09-17 10:00:07
```



The pattern above will produce the following output:

上面的模式将产生以下输出：



```
 symbol   lastPrice
======== ===========
 XYZ      16
```



The same query where `B*` is modified to `B*?`, which means that `B*` should be reluctant, will produce:

同样的查询 `B*` 被修改为 `B*？`，这意味着 `B*` 应该是 reluctant（不情愿的），将产生：



```
 symbol   lastPrice
======== ===========
 XYZ      13
 XYZ      16
```



The pattern variable `B` matches only to the row with price `12` instead of swallowing the rows with prices `12`, `13`, and `14`.

模式变量 `B` 仅匹配价格为 `12` 的行，而不是吞噬价格为 `12`，`13` 和 `14` 的行。

Attention It is not possible to use a greedy quantifier for the last variable of a pattern. Thus, a pattern like `(A B*)` is not allowed. This can be easily worked around by introducing an artificial state (e.g. `C`) that has a negated condition of `B`. So you could use a query like:

注意不可能将（greedy）贪婪量词用于模式的最后一个变量。因此，不允许像 `(A B*)` 那样的模式。通过引入具有 `B` 的否定条件的人工状态（例如`C`），可以很容易地解决这个问题。因此，可以使用如下查询：



```
PATTERN (A B* C)
DEFINE
    A AS condA(),
    B AS condB(),
    C AS NOT condB()
```



Attention The optional reluctant quantifier (`A??` or `A{0,1}?`) is not supported right now.

注意目前不支持可选的不情愿量词（`A??` 或 `A{0,1}?`）。

## Output Mode

## 输出模式

The _output mode_ describes how many rows should be emitted for every found match. The SQL standard describes two modes:

_输出模式(output mode)_ 描述了每次找到的匹配应该发出的行数。SQL标准描述了两种模式：

*   `ALL ROWS PER MATCH`
*   `ONE ROW PER MATCH`.
*   `每次匹配所有行（ALL ROWS PER MATCH）`
*   `每次匹配一行（ONE ROW PER MATCH）`。

Currently, the only supported output mode is `ONE ROW PER MATCH` that will always produce one output summary row for each found match.

目前，唯一支持的输出模式是 `ONE ROW PER MATCH`，它将始终为每个找到的匹配生成一个输出概要行。

The schema of the output row will be a concatenation of `[partitioning columns] + [measures columns]` in that particular order.

输出行的 schema，按照特定顺序显示 `[partitioning columns] + [measures columns]`。

The following example shows the output of a query defined as:

以下示例显示定义为以下内容的查询的输出：



```
SELECT *
FROM Ticker
    MATCH_RECOGNIZE(
        PARTITION BY symbol
        ORDER BY rowtime
        MEASURES
            FIRST(A.price) AS startPrice,
            LAST(A.price) AS topPrice,
            B.price AS lastPrice
        ONE ROW PER MATCH
        PATTERN (A+ B)
        DEFINE
            A AS LAST(A.price, 1) IS NULL OR A.price > LAST(A.price, 1),
            B AS B.price < LAST(A.price)
    )
```



For the following input rows:

下面是输入内容：



```
 symbol   tax   price          rowtime
======== ===== ======== =====================
 XYZ      1     10       2018-09-17 10:00:02
 XYZ      2     12       2018-09-17 10:00:03
 XYZ      1     13       2018-09-17 10:00:04
 XYZ      2     11       2018-09-17 10:00:05
```



The query will produce the following output:

该查询将生成以下输出：



```
 symbol   startPrice   topPrice   lastPrice
======== ============ ========== ===========
 XYZ      10           13         11
```



The pattern recognition is partitioned by the `symbol` column. Even though not explicitly mentioned in the `MEASURES` clause, the partitioned column is added at the beginning of the result.

模式识别由 `symbol` 列分区。即使未在 `MEASURES` 子句中明确提及，也会在结果的开头添加分区列。

## Pattern Navigation

## 模式导航

The `DEFINE` and `MEASURES` clauses allow for navigating within the list of rows that (potentially) match a pattern.

`DEFINE` 和`MEASURES` 子句允许在（可能）匹配模式的行列表中导航。

This section discusses this navigation for declaring conditions or producing output results.

这部分讨论声明条件或产生输出结果导航。

### Pattern Variable Referencing

### 模式变量引用

A _pattern variable reference_ allows a set of rows mapped to a particular pattern variable in the `DEFINE` or `MEASURES` clauses to be referenced.

_模式变量引用（pattern variable reference）_ 允许一组行映射一个特定的模式变量引用在 `DEFINE` 或 `MEASURES` 子句中。

For example, the expression `A.price` describes a set of rows mapped so far to `A` plus the current row if we try to match the current row to `A`. If an expression in the `DEFINE`/`MEASURES` clause requires a single row (e.g. `A.price` or `A.price &gt; 10`), it selects the last value belonging to the corresponding set.

例如，如果我们尝试将当前行与 `A` 匹配，则表达式 `A.price` 描述了到目前为止映射到 `A` 加上当前行的一组行。如果 `DEFINE`/`MEASURES` 子句中的表达式需要单行（例如 `A.price` 或 `A.price &gt; 10`），它将选择属于相应集的最后一个值。

If no pattern variable is specified (e.g. `SUM(price)`), an expression references the default pattern variable `*` which references all variables in the pattern. In other words, it creates a list of all the rows mapped so far to any variable plus the current row.

如果没有指定模式变量（例如`SUM(price)`），则表达式引用默认模式变量`*`，它引用模式中的所有变量。换句话说，它创建了到目前为止映射到任何变量加上当前行的所有行的列表。

#### Example

#### 例子

For a more thorough example, one can take a look at the following pattern and corresponding conditions:

有关更全面的示例，可以查看以下模式和相应的条件：



```
PATTERN (A B+)
DEFINE
  A AS A.price > 10,
  B AS B.price > A.price AND SUM(price) < 100 AND SUM(B.price) < 80
```



The following table describes how those conditions are evaluated for each incoming event.

下表描述了如何为每个传入事件评估这些条件。

The table consists of the following columns:

该表包含以下列：

*   `#` - the row identifier that uniquely identifies an incoming row in the lists `[A.price]`/`[B.price]`/`[price]`.
*   `#` - 唯一标识列表中 `[A.price]`/`[B.price]`/`[price]` 传入行的行标识符。
*   `price` - the price of the incoming row.
*   `price` - 传入行的 price。
*   `[A.price]`/`[B.price]`/`[price]` - describe lists of rows which are used in the `DEFINE` clause to evaluate conditions.
*   `[A.price]`/`[B.price]`/`[price]` - 描述在 `DEFINE` 子句中用于评估条件的行列表。
*   `Classifier` - the classifier of the current row which indicates the pattern variable the row is mapped to.
*   `Classifier` - 当前行的分类器，指示行映射到的模式变量。
*   `A.price`/`B.price`/`SUM(price)`/`SUM(B.price)` - describes the result after those expressions have been evaluated.
*   `A.price`/`B.price`/`SUM(price)`/`SUM(B.price)` - 描述了评估这些表达式后的结果。

| # | price | Classifier | [A.price] | [B.price] | [price] | A.price | B.price | SUM(price) | SUM(B.price) |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| #1 | 10 | -&gt; A | #1 | - | - | 10 | - | - | - |
| #2 | 15 | -&gt; B | #1 | #2 | #1, #2 | 10 | 15 | 25 | 15 |
| #3 | 20 | -&gt; B | #1 | #2, #3 | #1, #2, #3 | 10 | 20 | 45 | 35 |
| #4 | 31 | -&gt; B | #1 | #2, #3, #4 | #1, #2, #3, #4 | 10 | 31 | 76 | 66 |
| #5 | 35 |  | #1 | #2, #3, #4, #5 | #1, #2, #3, #4, #5 | 10 | 35 | 111 | 101 |

As can be seen in the table, the first row is mapped to pattern variable `A` and subsequent rows are mapped to pattern variable `B`. However, the last row does not fulfill the `B` condition because the sum over all mapped rows `SUM(price)` and the sum over all rows in `B` exceed the specified thresholds.

从表中可以看出，第一行映射到模式变量 `A`，后续行映射到模式变量 `B`。但是，最后一行不满足 `B` 条件，因为所有映射行的总和 `SUM(price)` 和 `B` 中所有行的总和超过指定的阈值。

Attention Please note that aggregations such as `SUM` are not supported yet. They are only used for explanation here.

注意请注意，尚不支持 `SUM` 等聚合。它们仅用于解释。

### Logical Offsets

### 逻辑偏移

_Logical offsets_ enable navigation within the events that were mapped to a particular pattern variable. This can be expressed with two corresponding functions:

_逻辑偏移(Logical offsets)_ 启用映射到特定模式变量的事件中的导航。这可以用两个相应的函数表示：

| Offset functions | Description |
| --- | --- |
|```LAST(variable.field, n)``` | Returns the value of the field from the event that was mapped to the _n_-th _last_ element of the variable. The counting starts at the last element mapped. |
|```FIRST(variable.field, n)``` | Returns the value of the field from the event that was mapped to the _n_-th element of the variable. The counting starts at the first element mapped. |

| Offset 函数 | 描述 |
| --- | --- |
|```LAST(variable.field, n)``` | 返回映射到变量的第 _n_ 个 _最后_ 一个元素的事件的字段值。计数从映射的最后一个元素开始。 |
|```FIRST(variable.field, n)``` | 从映射到变量的第 _n_ 个元素的事件返回字段的值。 计数从映射的第一个元素开始。 |


#### Examples

#### 例子

For a more thorough example, one can take a look at the following pattern and corresponding conditions:

有关更全面的示例，可以查看以下模式和相应的条件



```
PATTERN (A B+)
DEFINE
  A AS A.price > 10,
  B AS (LAST(B.price, 1) IS NULL OR B.price > LAST(B.price, 1)) AND
       (LAST(B.price, 2) IS NULL OR B.price > 2 * LAST(B.price, 2))
```



The following table describes how those conditions are evaluated for each incoming event.

下表描述了如何为每个传入事件评估这些条件。

The table consists of the following columns:

该表包含以下列：

*   `price` - the price of the incoming row.
*   `price` - 传入行的价格。
*   `Classifier` - the classifier of the current row which indicates the pattern variable the row is mapped to.
*   `Classifier` -  当前行的分类器，指示行映射到的模式变量。
*   `LAST(B.price, 1)`/`LAST(B.price, 2)` - describes the result after those expressions have been evaluated.
*   `LAST(B.price, 1)`/`LAST(B.price, 2)` - 描述评估这些表达式后的结果。

| price | Classifier | LAST(B.price, 1) | LAST(B.price, 2) | Comment |
| --- | --- | --- | --- | --- |
| 10 | -&gt; A |  |  |  |
| 15 | -&gt; B | null | null | Notice that `LAST(A.price, 1)` is null because there is still nothing mapped to `B`. |
| 20 | -&gt; B | 15 | null |  |
| 31 | -&gt; B | 20 | 15 |  |
| 35 |  | 31 | 20 | Not mapped because `35 &lt; 2 * 20`. |

| price | Classifier | LAST(B.price, 1) | LAST(B.price, 2) | Comment |
| --- | --- | --- | --- | --- |
| 10 | -&gt; A |  |  |  |
| 15 | -&gt; B | null | null | 注意：`LAST(A.price, 1)` 是 null 因为没有值映射到 `B`。 |
| 20 | -&gt; B | 15 | null |  |
| 31 | -&gt; B | 20 | 15 |  |
| 35 |  | 31 | 20 | 没有映射因为 `35 &lt; 2 * 20`。 |

It might also make sense to use the default pattern variable with logical offsets.

将默认模式变量与逻辑偏移一起使用也可能有意义。

In this case, an offset considers all the rows mapped so far:

在这种情况下，偏移量会考虑到目前为止映射的所有行：



```
PATTERN (A B? C)
DEFINE
  B AS B.price < 20,
  C AS LAST(price, 1) < C.price
```



| price | Classifier | LAST(price, 1) | Comment |
| --- | --- | --- | --- |
| 10 | -&gt; A |  |  |
| 15 | -&gt; B |  |  |
| 20 | -&gt; C | 15 | `LAST(price, 1)` is evaluated as the price of the row mapped to the `B` variable. |

| price | Classifier | LAST(price, 1) | Comment |
| --- | --- | --- | --- |
| 10 | -&gt; A |  |  |
| 15 | -&gt; B |  |  |
| 20 | -&gt; C | 15 | `LAST(price, 1)` 被评估为映射到 `B` 变量的行的价格。 |

If the second row did not map to the `B` variable, we would have the following results:

如果第二行没有映射到 `B` 变量，我们将得到以下结果：

| price | Classifier | LAST(price, 1) | Comment |
| --- | --- | --- | --- |
| 10 | -&gt; A |  |  |
| 20 | -&gt; C | 10 | `LAST(price, 1)` is evaluated as the price of the row mapped to the `A` variable. |

| price | Classifier | LAST(price, 1) | Comment |
| --- | --- | --- | --- |
| 10 | -&gt; A |  |  |
| 20 | -&gt; C | 10 | `LAST(price, 1)` 被评估为映射到 `A` 变量的行的价格。 |

It is also possible to use multiple pattern variable references in the first argument of the `FIRST/LAST` functions. This way, one can write an expression that accesses multiple columns. However, all of them must use the same pattern variable. In other words, the value of the `LAST`/`FIRST` function must be computed in a single row.

也可以在多个模式变量中引用 `FIRST/LAST` 函数的第一个参数。这样可以写一个访问多个列的表达式。但是这些都必须使用相同的模式变量。换句话说，`LAST`/`FIRST` 函数的值必须是在单行中计算。

Thus, it is possible to use `LAST(A.price * A.tax)`, but an expression like `LAST(A.price * B.tax)` is not allowed.

因此，可以使用 `LAST(A.price * A.tax)`，但不允许使用类似 `LAST(A.price * B.tax)` 的表达式。

## After Match Strategy

## 匹配策略后

The `AFTER MATCH SKIP` clause specifies where to start a new matching procedure after a complete match was found.

`AFTER MATCH SKIP` 子句指定在找到完整匹配后开始新匹配过程的位置。

There are four different strategies:

有四种不同的策略：

*   `SKIP PAST LAST ROW` - resumes the pattern matching at the next row after the last row of the current match.
*   `SKIP PAST LAST ROW` - 在当前匹配的最后一行之后的下一行恢复模式匹配。
*   `SKIP TO NEXT ROW` - continues searching for a new match starting at the next row after the starting row of the match.
*   `SKIP TO NEXT ROW` - 继续在匹配的起始行之后的下一行开始搜索新的匹配。
*   `SKIP TO LAST variable` - resumes the pattern matching at the last row that is mapped to the specified pattern variable.
*   `SKIP TO LAST variable` - 在映射到指定模式变量的最后一行恢复模式匹配。
*   `SKIP TO FIRST variable` - resumes the pattern matching at the first row that is mapped to the specified pattern variable.
*   `SKIP TO FIRST variable` - 在映射到指定模式变量的第一行恢复模式匹配。

This is also a way to specify how many matches a single event can belong to. For example, with the `SKIP PAST LAST ROW` strategy every event can belong to at most one match.

这也是一种指定单个事件可以属于多少匹配的方法。例如，使用 `SKIP PAST LAST ROW` 策略，每个事件最多只能属于一个匹配项。

#### Examples

#### 例子

In order to better understand the differences between those strategies one can take a look at the following example.

为了更好地理解这些策略之间的差异，可以查看以下示例。

For the following input rows:

对于以下输入行：



```
 symbol   tax   price         rowtime
======== ===== ======= =====================
 XYZ      1     7       2018-09-17 10:00:01
 XYZ      2     9       2018-09-17 10:00:02
 XYZ      1     10      2018-09-17 10:00:03
 XYZ      2     5       2018-09-17 10:00:04
 XYZ      2     17      2018-09-17 10:00:05
 XYZ      2     14      2018-09-17 10:00:06
```



We evaluate the following query with different strategies:

我们使用不同的策略评估以下查询：



```
SELECT *
FROM Ticker
    MATCH_RECOGNIZE(
        PARTITION BY symbol
        ORDER BY rowtime
        MEASURES
            SUM(A.price) AS sumPrice,
            FIRST(rowtime) AS startTime,
            LAST(rowtime) AS endTime
        ONE ROW PER MATCH
        [AFTER MATCH STRATEGY]
        PATTERN (A+ C)
        DEFINE
            A AS SUM(A.price) < 30
    )
```



The query returns the sum of the prices of all rows mapped to `A` and the first and last timestamp of the overall match.

查询返回映射到 `A` 的所有行的价格总和以及整个匹配的第一个和最后一个时间戳。

Attention Please note that aggregations such as `SUM` are not supported yet. They are only used for explanation here.

请注意，尚不支持 `SUM` 等聚合。它们仅用于解释。

The query will produce different results based on which `AFTER MATCH` strategy was used:

查询将根据使用的 `AFTER MATCH` 策略产生不同的结果：

##### `AFTER MATCH SKIP PAST LAST ROW`

##### `AFTER MATCH SKIP PAST LAST ROW`



```
 symbol   sumPrice        startTime              endTime
======== ========== ===================== =====================
 XYZ      26         2018-09-17 10:00:01   2018-09-17 10:00:04
 XYZ      17         2018-09-17 10:00:05   2018-09-17 10:00:06
```



The first result matched against the rows #1, #2, #3, #4.

第一个结果与行 #1, #2, #3, #4 匹配。

The second result matched against the rows #5, #6.

第二个结果与行 #5, #6 匹配。

##### `AFTER MATCH SKIP TO NEXT ROW`

##### `AFTER MATCH SKIP TO NEXT ROW`



```
 symbol   sumPrice        startTime              endTime
======== ========== ===================== =====================
 XYZ      26         2018-09-17 10:00:01   2018-09-17 10:00:04
 XYZ      24         2018-09-17 10:00:02   2018-09-17 10:00:05
 XYZ      15         2018-09-17 10:00:03   2018-09-17 10:00:05
 XYZ      22         2018-09-17 10:00:04   2018-09-17 10:00:06
 XYZ      17         2018-09-17 10:00:05   2018-09-17 10:00:06
```



Again, the first result matched against the rows #1, #2, #3, #4.

同样，第一个结果与行 #1, #2, #3, #4 匹配。

Compared to the previous strategy, the next match includes row #2 again for the next matching. Therefore, the second result matched against the rows #2, #3, #4, #5.

与先前的策略相比，下一个匹配包括再次用于下一个匹配的行 #2 。 因此，第二个结果与行 #2, #3, #4, #5 匹配。

The third result matched against the rows #3, #4, #5.

第三个结果与行 #3, #4, #5 匹配。

The forth result matched against the rows #4, #5, #6.

第四个结果与行 #4, #5, #6 相匹配。

The last result matched against the rows #5, #6.

最后一个结果与行 #5, #6 匹配。

##### `AFTER MATCH SKIP TO LAST A`

##### `AFTER MATCH SKIP TO LAST A`



```
 symbol   sumPrice        startTime              endTime
======== ========== ===================== =====================
 XYZ      26         2018-09-17 10:00:01   2018-09-17 10:00:04
 XYZ      15         2018-09-17 10:00:03   2018-09-17 10:00:05
 XYZ      22         2018-09-17 10:00:04   2018-09-17 10:00:06
 XYZ      17         2018-09-17 10:00:05   2018-09-17 10:00:06
```



Again, the first result matched against the rows #1, #2, #3, #4.

同样，第一个结果与行 #1, #2, #3, #4 匹配。

Compared to the previous strategy, the next match includes only row #3 (mapped to `A`) again for the next matching. Therefore, the second result matched against the rows #3, #4, #5.

与之前的策略相比，下一个匹配仅包括第 #3 行（映射到 `A` ）以进行下一次匹配。因此，第二个结果与行 #3, #4, #5 匹配。

The third result matched against the rows #4, #5, #6.

第三个结果与行 #4, #5, #6 匹配。

The last result matched against the rows #5, #6.

最后一个结果与行 #5, #6 匹配。

##### `AFTER MATCH SKIP TO FIRST A`

##### `AFTER MATCH SKIP TO FIRST A`

This combination will produce a runtime exception because one would always try to start a new match where the last one started. This would produce an infinite loop and, thus, is prohibited.

此组合将产生运行时异常，因为总是会尝试启动最后一个匹配的新匹配。 这将产生无限循环，因此被禁止。

One has to keep in mind that in case of the `SKIP TO FIRST/LAST variable` strategy it might be possible that there are no rows mapped to that variable (e.g. for pattern `A*`). In such cases, a runtime exception will be thrown as the standard requires a valid row to continue the matching.

必须记住，在 `SKIP TO FIRST/LAST variable` 变量策略的情况下，可能没有行映射到该变量（例如，对于模式 `A*`）。在这种情况下，将抛出运行时异常，因为标准需要有效行来继续匹配。

### Controlling Memory Consumption

### 控制内存消耗

Memory consumption is an important consideration when writing `MATCH_RECOGNIZE` queries, as the space of potential matches is built in a breadth-first-like manner. Having that in mind, one must make sure that the pattern can finish. Preferably with a reasonable number of rows mapped to the match as they have to fit into memory.

在编写 `MATCH_RECOGNIZE` 查询时，内存消耗是一个重要的考虑因素，因为潜在匹配的空间是以类似于广度的方式（a breadth-first-like manner）构建的。考虑到这一点，必须确保模式可以完成。优选地，具有映射到匹配的合理数量的行，因为它们必须适合内存。

For example, the pattern must not have a quantifier without an upper limit that accepts every single row. Such a pattern could look like this:

例如，模式不能有没有上限的量词，接受访问每个单行（row）。这样的模式可能如下所示：



```
PATTERN (A B+ C)
DEFINE
  A as A.price > 10,
  C as C.price > 20
```



The query will map every incoming row to the `B` variable and thus will never finish. This query could be fixed, e.g., by negating the condition for `C`:

查询将每个传入的行映射到 `B` 变量，因此永远不会完成。该查询可以是固定的，例如，通过否定 `C` 的条件：



```
PATTERN (A B+ C)
DEFINE
  A as A.price > 10,
  B as B.price <= 20,
  C as C.price > 20
```



Or by using the [reluctant quantifier](#greedy--reluctant-quantifiers):

或者通过使用[不情愿的量词(reluctant quantifier)](#greedy--reluctant-quantifiers)：



```
PATTERN (A B+? C)
DEFINE
  A as A.price > 10,
  C as C.price > 20
```



Attention Please note that the `MATCH_RECOGNIZE` clause does not use a configured [state retention time](query_configuration.html#idle-state-retention-time). As of now, there is also no possibility to define a time restriction on the pattern to finish because there is no such possibility in the SQL standard. The community is in the process of designing a proper syntax for that feature right now.

请注意，`MATCH_RECOGNIZE` 子句不使用已配置的[状态保留时间(state retention time)](query_configuration.html#idle-state-retention-time)。 截至目前，也没有可能在模式上定义时间限制，因为在SQL标准中没有这种可能性。社区正在为该功能设计正确的语法。

## Known Limitations

## 已知限制

Flink’s implementation of the `MATCH_RECOGNIZE` clause is an ongoing effort, and some features of the SQL standard are not yet supported.

Flink 的 `MATCH_RECOGNIZE` 子句的实现是一项持续的工作，并且还不支持SQL标准的某些功能。

Unsupported features include:

不支持的功能包括：

*   Pattern expressions:
*   模式表达式：
    *   Pattern groups - this means that e.g. quantifiers can not be applied to a subsequence of the pattern. Thus, `(A (B C)+)` is not a valid pattern.
    *   模式组（Pattern groups）- 这意味着例如量词不能应用于模式的子序列。因此，`(A (B C)+)` 不是有效模式。
    *   Alterations - patterns like `PATTERN((A B | C D) E)`, which means that either a subsequence `A B` or `C D` has to be found before looking for the `E` row.
    *   改变（Alterations）- 像 `PATTERN((A B | C D) E)` 这样的模式，这意味着在寻找 `E` 行之前必须找到子序列 `A B` 或 `C D`.
    *   `PERMUTE` operator - which is equivalent to all permutations of variables that it was applied to e.g. `PATTERN (PERMUTE (A, B, C))` = `PATTERN (A B C | A C B | B A C | B C A | C A B | C B A)`.
    *   `PERMUTE` 运算符 - 相当于它应用于的所有变量的排列，例如 `PATTERN (PERMUTE (A, B, C))` = `PATTERN (A B C | A C B | B A C | B C A | C A B | C B A)`。
    *   Anchors - `^, $`, which denote beginning/end of a partition, those do not make sense in the streaming context and will not be supported.
    *   Anchors -  `^, $` 表示分区的开始/结束，那些在流上下文中没有意义，并且不受支持。
    *   Exclusion - `PATTERN ({- A -} B)` meaning that `A` will be looked for but will not participate in the output. This works only for the `ALL ROWS PER MATCH` mode.
    *   排除（Exclusion）-  `PATTERN ({- A -} B)` 意味着将查找 `A` 但不参与输出。这仅适用于 `ALL ROWS PER MATCH` 模式。
    *   Reluctant optional quantifier - `PATTERN A??` only the greedy optional quantifier is supported.
    *   不情愿的可选量词（Reluctant optional quantifier）- `PATTERN A??` 只支持贪婪的可选（greedy）量词。
*   `ALL ROWS PER MATCH` output mode - which produces an output row for every row that participated in the creation of a found match. This also means:
*   `ALL ROWS PER MATCH` 输出模式 - 为参与创建匹配的每一行产生输出行。这也意味着：
    *   that the only supported semantic for the `MEASURES` clause is `FINAL`
    *   `MEASURES` 子句唯一支持的语义是 `FINAL`
    *   `CLASSIFIER` function, which returns the pattern variable that a row was mapped to, is not yet supported.
    *   尚未支持 `CLASSIFIER` 函数，该函数返回行映射到的模式变量。
*   `SUBSET` - which allows creating logical groups of pattern variables and using those groups in the `DEFINE` and `MEASURES` clauses.
*   `SUBSET` - 允许创建模式变量的逻辑组并在 `DEFINE` 和 `MEASURES` 子句中使用这些组。
*   Physical offsets - `PREV/NEXT`, which indexes all events seen rather than only those that were mapped to a pattern variable(as in [logical offsets](#logical-offsets) case).
*   物理偏移（Physical offsets）- `PREV/NEXT`，它对所有看到的事件进行索引，而不仅仅是那些映射到模式变量的事件（如在[逻辑偏移](#logical-offsets)情况下）。
*   Extracting time attributes - there is currently no possibility to get a time attribute for subsequent time-based operations.
*   提取时间属性（Extracting time attributes） - 目前无法为后续基于时间的操作获取时间属性。
*   Aggregates - one cannot use aggregates in `MEASURES` nor `DEFINE` clauses.
*   聚合（Aggregates）- 在 `MEASURES` 和 `DEFINE` 子句中不能使用聚合。
*   User defined functions cannot be used within `MATCH_RECOGNIZE`.
*   用户定义的函数不能在 `MATCH_RECOGNIZE` 中使用。
*   `MATCH_RECOGNIZE` is supported only for SQL. There is no equivalent in the Table API.
*   仅支持SQL `MATCH_RECOGNIZE`。表API中没有等价物。
