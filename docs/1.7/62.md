

# Joins in Continuous Queries

# Joins 连续查询

Joins are a common and well-understood operation in batch data processing to connect the rows of two relations. However, the semantics of joins on [dynamic tables](dynamic_tables.html) are much less obvious or even confusing.

Joins 是批数据处理中常见且易于理解的操作，用于连接两个关系的行。但是，[动态表](dynamic_tables.html)上的连接语义不太明显甚至令人困惑。

Because of that, there are a couple of ways to actually perform a join using either Table API or SQL.

因此，有几种方法可以使用 Table API 或 SQL 实际执行连接。

For more information regarding the syntax, please check the join sections in [Table API](../tableApi.html#joins) and [SQL](../sql.html#joins).

有关语法的更多信息，请查看 [Table API](../tableApi.html#joins) 和 [SQL](../sql.html#joins) 中的连接部分。

## Regular Joins

## 常规联接

Regular joins are the most generic type of join in which any new records or changes to either side of the join input are visible and are affecting the whole join result. For example, if there is a new record on the left side, it will be joined with all of the previous and future records on the right side.

常规联接是最通用的联接类型，其中任何新记录或对联接输入任一侧的更改都是可见的并且影响整个联接结果。例如，如果左侧有新记录，则它将与右侧的所有先前和未来记录进行连接。



```
SELECT * FROM Orders
INNER JOIN Product
ON Orders.productId = Product.id
```



These semantics allow for any kind of updating (insert, update, delete) input tables.

这些语义允许任何类型的更新（插入，更新，删除）输入表。

However, this operation has an important implication: it requires to keep both sides of the join input in Flink’s state forever. Thus, the resource usage will grow indefinitely as well, if one or both input tables are continuously growing.

但是，此操作具有重要意义：它需要将连接输入的两侧永久保持在Flink的状态。 因此，如果一个或两个输入表不断增长，资源使用也将无限增长。

## Time-windowed Joins

## 时间窗口连接

A time-windowed join is defined by a join predicate, that checks if the [time attributes](time_attributes.html) of the input records are within certain time constraints, i.e., a time window.

基于时间窗口的连接由连接谓词定义，该连接谓词检查输入记录的[时间属性](time_attributes.html)是否在某些时间限制内，即时间窗口。



```
SELECT *
FROM
  Orders o,
  Shipments s
WHERE o.id = s.orderId AND
      o.ordertime BETWEEN s.shiptime - INTERVAL '4' HOUR AND s.shiptime
```



Compared to a regular join operation, this kind of join only supports append-only tables with time attributes. Since time attributes are quasi-monontic increasing, Flink can remove old values from its state without affecting the correctness of the result.

与常规连接操作相比，此类连接仅支持具有时间属性的仅追加表(append-only tables)。由于时间属性是 quasi-monontic 增加，Flink可以从其状态中删除旧值而不影响结果的正确性。

## Join with a Temporal Table

## 时态表连接

A join with a temporal table joins an append-only table (left input/probe side) with a temporal table (right input/build side), i.e., a table that changes over time and tracks its changes. Please check the corresponding page for more information about [temporal tables](temporal_tables.html).

具有时态表的连接将仅追加(append-only)表（左输入/探测侧）与时态表（右输入/构建侧）连接，即随时间变化并跟踪其变化的表。 有关[时态表](temporal_tables.html)的更多信息，请查看相应的页面。

The following example shows an append-only table `Orders` that should be joined with the continuously changing currency rates table `RatesHistory`.

以下示例显示了一个仅附加表 `Orders`，它应与不断变化的货币汇率表 `RatesHistory` 连接。

`Orders` is an append-only table that represents payments for the given `amount` and the given `currency`. For example at `10:15` there was an order for an amount of `2 Euro`.

`Orders` 是一个仅附加表，表示给定 `金额` 和给定 `货币` 的付款。 例如，在 `10：15`，订单金额为 `2欧元`。



```
SELECT * FROM Orders;

rowtime amount currency
======= ====== =========
10:15        2 Euro
10:30        1 US Dollar
10:32       50 Yen
10:52        3 Euro
11:04        5 US Dollar
```



`RatesHistory` represents an ever changing append-only table of currency exchange rates with respect to `Yen` (which has a rate of `1`). For example, the exchange rate for the period from `09:00` to `10:45` of `Euro` to `Yen` was `114`. From `10:45` to `11:15` it was `116`.

`RatesHistory` 代表一个不断变化的仅追加货币汇率表，相对于 `Yen`（汇率为 `1`）。例如，从 `09：00` 到 `10：45` 的`欧元`到`日元`期间的汇率为 `114`。 从 `10:45` 到 `11：15`，它是 `116` 。



```
SELECT * FROM RatesHistory;

rowtime currency   rate
======= ======== ======
09:00   US Dollar   102
09:00   Euro        114
09:00   Yen           1
10:45   Euro        116
11:15   Euro        119
11:49   Pounds      108
```



Given that we would like to calculate the amount of all `Orders` converted to a common currency (`Yen`).

鉴于我们想要计算转换为通用货币（`日元`）的所有 `Orders` 的数量。

For example, we would like to convert the following order using the appropriate conversion rate for the given `rowtime` (`114`).

例如，我们希望使用给定 `rowtime`（`114`）的适当转换率转换以下顺序。



```
rowtime amount currency
======= ====== =========
10:15        2 Euro
```



Without using the concept of [temporal tables](temporal_tables.html), one would need to write a query like:

如果不使用[时态表](temporal_tables.html)的概念，就需要编写如下查询：



```
SELECT
  SUM(o.amount * r.rate) AS amount
FROM Orders AS o,
  RatesHistory AS r
WHERE r.currency = o.currency
AND r.rowtime = (
  SELECT MAX(rowtime)
  FROM RatesHistory AS r2
  WHERE r2.currency = o.currency
  AND r2.rowtime <= o.rowtime);
```



With the help of a temporal table function `Rates` over `RatesHistory`, we can express such a query in SQL as:

借助于一个时间表函数 `Rates` 而不是 `RatesHistory`，我们可以在SQL中表达这样一个查询：



```
SELECT
  o.amount * r.rate AS amount
FROM
  Orders AS o,
  LATERAL TABLE (Rates(o.rowtime)) AS r
WHERE r.currency = o.currency
```



Each record from the probe side will be joined with the version of the build side table at the time of the correlated time attribute of the probe side record. In order to support updates (overwrites) of previous values on the build side table, the table must define a primary key.

来自探测器侧的每个记录将在探测器侧记录的相关时间属性时与构建侧表的版本连接。为了支持构建端表上先前值的更新（覆盖），该表必须定义主键。

In our example, each record from `Orders` will be joined with the version of `Rates` at time `o.rowtime`. The `currency` field has been defined as the primary key of `Rates` before and is used to connect both tables in our example. If the query were using a processing-time notion, a newly appended order would always be joined with the most recent version of `Rates` when executing the operation.

在我们的例子中，来自 `Orders `的每条记录将在 `o.rowtime` 时加入 `Rates` 的版本。`currency` 字段已被定义为之前 `Rates` 的主键，用于连接我们示例中的两个表。如果查询使用处理时间概念，则在执行操作时，新添加的订单将始终与最新版本的 `Rates` 连接。

In contrast to [regular joins](#regular-joins), this means that if there is a new record on the build side, it will not affect the previous results of the join. This again allows Flink to limit the number of elements that must be kept in the state.

与[常规连接](#regular-joins)相反，这意味着如果构建端有新记录，则不会影响以前的连接结果。这再次允许 Flink 限制必须保持在该状态的元素的数量。

Compared to [time-windowed joins](#time-windowed-joins), temporal table joins do not define a time window within which bounds the records will be joined. Records from the probe side are always joined with the build side’s version at the time specified by the time attribute. Thus, records on the build side might be arbitrarily old. As time passes, the previous and no longer needed versions of the record (for the given primary key) will be removed from the state.

与[time-windowed join](#time-windowed-joins)相比，时态表连接不定义时间窗口（时间窗口内的数据将会被join）。探针端的记录始终与 time 属性指定的构建端版本连接。因此，构建方面的记录可能是任意旧的。随着时间的推移，将从状态中删除先前和不再需要的记录版本（对于给定的主键）。

Such behaviour makes a temporal table join a good candidate to express stream enrichment in relational terms.

这种行为使得时态表加入了一个很好的候选者来表达关系术语中的流富集。

### Usage

### 用法

After [defining temporal table function](temporal_tables.html#defining-temporal-table-function), we can start using it. Temporal table functions can be used in the same way as normal table functions would be used.

[定义时态表函数](temporal_tables.html#defining-temporal-table-function)后，我们可以开始使用它。时态表函数的使用方式与使用普通表函数的方式相同。

The following code snippet solves our motivating problem of converting currencies from the `Orders` table:

以下代码片段解决了我们从 `订单` 表转换货币的问题：



```
SELECT
  SUM(o_amount * r_rate) AS amount
FROM
  Orders,
  LATERAL TABLE (Rates(o_proctime))
WHERE
  r_currency = o_currency
```





```
Table result = orders
    .join(new Table(tEnv, "rates(o_proctime)"), "o_currency = r_currency")
    .select("(o_amount * r_rate).sum as amount");
```





```
val result = orders
    .join(rates('o_proctime), 'r_currency === 'o_currency)
    .select(('o_amount * 'r_rate).sum as 'amount)
```



**Note**: State retention defined in a [query configuration](query_configuration.html) is not yet implemented for temporal joins. This means that the required state to compute the query result might grow infinitely depending on the number of distinct primary keys for the history table.

**注意**：在时间连接中尚未实现在[查询配置](query_configuration.html)中定义的状态保留。这意味着计算查询结果所需的状态可能会无限增长，具体取决于历史记录表的不同主键的数量。

### Processing-time Temporal Joins

### 处理时间时态连接

With a processing-time time attribute, it is impossible to pass _past_ time attributes as an argument to the temporal table function. By definition, it is always the current timestamp. Thus, invocations of a processing-time temporal table function will always return the latest known versions of the underlying table and any updates in the underlying history table will also immediately overwrite the current values.

使用处理时间时间属性，不可能将 _过去_ 时间属性作为参数传递给时态表函数。根据定义，它始终是当前时间戳。因此，处理时间时间表函数的调用将始终返回基础表的最新已知版本，并且基础历史表中的任何更新也将立即覆盖当前值。

Only the latest versions (with respect to the defined primary key) of the build side records are kept in the state. Updates of the build side will have no effect on previously emitted join results.

只有构建端记录的最新版本（相对于已定义的主键）保留在该状态中。构建端的更新将不会影响先前发出的连接结果。

One can think about a processing-time temporal join as a simple `HashMap&lt;K, V&gt;` that stores all of the records from the build side. When a new record from the build side has the same key as some previous record, the old value is just simply overwritten. Every record from the probe side is always evaluated against the most recent/current state of the `HashMap`.

可以将处理时间时态连接视为一个简单的 `HashMap<K, V>;`，它存储来自构建方的所有记录。当构建端的新记录具有与先前记录相同的密钥 key 时，旧值只是被覆盖。探测器端的每条记录总是根据 `HashMap` 的最新/当前状态进行评估。

### Event-time Temporal Joins

### 事件时间时态连接

With an event-time time attribute (i.e., a rowtime attribute), it is possible to pass _past_ time attributes to the temporal table function. This allows for joining the two tables at a common point in time.

利用事件时间属性（即 rowtime 属性），可以将 _过去_ 时间属性传递给时态表函数。这允许在共同的时间点连接两个表。

Compared to processing-time temporal joins, the temporal table does not only keep the latest version (with respect to the defined primary key) of the build side records in the state but stores all versions (identified by time) since the last watermark.

与处理时间时态连接相比，时态表不仅保持状态中的构建侧记录的最新版本（相对于定义的主键），而且存储自上一个水印以来的所有版本（由时间标识）。

For example, an incoming row with an event-time timestamp of `12:30:00` that is appended to the probe side table is joined with the version of the build side table at time `12:30:00` according to the [concept of temporal tables](temporal_tables.html). Thus, the incoming row is only joined with rows that have a timestamp lower or equal to `12:30:00` with applied updates according to the primary key until this point in time.

例如，根据[时态表的概念](temporal_tables.html)附加到探测器侧表的事件时间时间戳为 `12：30：00` 的传入行与时间 `12：30：00` 的构建端表的版本连接在一起。因此，传入的行仅与时间戳小于或等于 `12：30：00` 的行连接，并根据主键应用更新，直到此时为止。

By definition of event time, [watermarks](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/event_time.html) allow the join operation to move forward in time and discard versions of the build table that are no longer necessary because no incoming row with lower or equal timestamp is expected.

根据事件时间的定义，[watermarks](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/event_time.html) 允许连接操作及时向前移动并丢弃不再需要的构建表的版本，因为不期望具有较低或相等时间戳的传入行。
