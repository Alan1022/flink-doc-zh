

# User-defined Sources & Sinks

# 用户定义的 Sources 和 Sinks

A `TableSource` provides access to data which is stored in external systems (database, key-value store, message queue) or files. After a [TableSource is registered in a TableEnvironment](common.html#register-a-tablesource) it can be accessed by [Table API](tableApi.html) or [SQL](sql.html) queries.

`TableSource` 提供对存储在外部系统(数据库、键值存储、消息队列)或文件中的数据的访问。[TableSource 在 TableEnvironment 中注册后](common.html#register-a-tablesource)可以通过[Table API](tableApi.html)或[SQL](sql.html)查询访问它。

A `TableSink` [emits a Table](common.html#emit-a-table) to an external storage system, such as a database, key-value store, message queue, or file system (in different encodings, e.g., CSV, Parquet, or ORC).

`TableSink`[发送 Table](common.html#emit-a-table)到外部存储系统，如数据库、键值存储、消息队列或文件系统(以不同的编码方式，如 CSV、Parquet 或 ORC)。

A `TableFactory` allows for separating the declaration of a connection to an external system from the actual implementation. A table factory creates configured instances of table sources and sinks from normalized, string-based properties. The properties can be generated programmatically using a `Descriptor` or via YAML configuration files for the [SQL Client](sqlClient.html).

`TableFactory` 允许将与外部系统的连接声明与实际实现分离。表工厂从规范化的、基于字符串的属性创建表源(sources)和表接收器(sinks)的已配置实例。可以使用`描述符(Descriptor)`以编程方式生成属性，也可以通过[SQL Client](sqlClient.html)的YAML配置文件生成属性。

Have a look at the [common concepts and API](common.html) page for details how to [register a TableSource](common.html#register-a-tablesource) and how to [emit a Table through a TableSink](common.html#emit-a-table). See the [built-in sources, sinks, and formats](connect.html) page for examples how to use factories.

查看[常见概念和API](common.html)页面，了解如何[注册TableSource](common.html#register-a-tablesource)以及如何[通过 TableSink 发出 Table](common.html#emit-a-table)的详细信息。有关如何使用工厂的示例，请参阅[内置源，接收器和格式](connect.html)页面。

## Define a TableSource

## 定义一个表源(TableSource)

A `TableSource` is a generic interface that gives Table API and SQL queries access to data stored in an external system. It provides the schema of the table and the records that are mapped to rows with the table’s schema. Depending on whether the `TableSource` is used in a streaming or batch query, the records are produced as a `DataSet` or `DataStream`.

`TableSource` 是一个通用接口，允许 Table API 和 SQL 查询访问存储在外部系统中的数据。它提供了表的模式以及映射到具有表模式的行的记录。根据是否在流式或批量查询中使用 `TableSource`，记录将作为 `DataSet` 或 `DataStream` 生成。

If a `TableSource` is used in a streaming query it must implement the `StreamTableSource` interface, if it is used in a batch query it must implement the `BatchTableSource` interface. A `TableSource` can also implement both interfaces and be used in streaming and batch queries.

如果在流查询中使用 `TableSource`，它必须实现 `StreamTableSource` 接口；如果在批处理查询中使用它，它必须实现 `BatchTableSource` 接口。`TableSource` 还可以实现这两个接口，并可用于流查询和批处理查询。

`StreamTableSource` and `BatchTableSource` extend the base interface `TableSource` that defines the following methods:

`StreamTableSource` 和 `BatchTableSource` 扩展了定义了以下方法的基本接口 `TableSource`:



```
TableSource<T> {

  public TableSchema getTableSchema();

  public TypeInformation<T> getReturnType();

  public String explainSource();
}
```





```
TableSource[T] {

  def getTableSchema: TableSchema

  def getReturnType: TypeInformation[T]

  def explainSource: String

}
```



*   `getTableSchema()`: Returns the schema of the table, i.e., the names and types of the fields of the table. The field types are defined using Flink’s `TypeInformation` (see [Table API types](tableApi.html#data-types) and [SQL types](sql.html#data-types)).

*   `getTableSchema()`: 返回表的模式，即表中字段的名称和类型。字段类型是使用 Flink 的 `类型信息(TypeInformation)`(参见[Table API types](tableApi.html#data-types)和[SQL types](sql.html#data-types))定义的。

*   `getReturnType()`: Returns the physical type of the `DataStream` (`StreamTableSource`) or `DataSet` (`BatchTableSource`) and the records that are produced by the `TableSource`.

*   `getReturnType()`: 返回 `DataStream` (`StreamTableSource`) 或 `DataSet` (`BatchTableSource`) 的物理类型和由 `TableSource` 生成的记录。

*   `explainSource()`: Returns a String that describes the `TableSource`. This method is optional and used for display purposes only.

*   `explainSource()`: 返回描述 `TableSource` 的字符串。此方法是可选的，仅用于显示目的。

The `TableSource` interface separates the logical table schema from the physical type of the returned `DataStream` or `DataSet`. As a consequence, all fields of the table schema (`getTableSchema()`) must be mapped to a field with corresponding type of the physical return type (`getReturnType()`). By default, this mapping is done based on field names. For example, a `TableSource` that defines a table schema with two fields `[name: String, size: Integer]` requires a `TypeInformation` with at least two fields called `name` and `size` of type `String` and `Integer`, respectively. This could be a `PojoTypeInfo` or a `RowTypeInfo` that have two fields named `name` and `size` with matching types.

`TableSource` 接口将逻辑表模式与返回的 `DataStream` 或 `DataSet` 的物理类型分开。因此，表模式(`getTableSchema()`)的所有字段必须映射到物理返回类型(`getReturnType()`)的对应类型的字段。默认情况下，这个映射是基于字段名完成的。例如，定义具有两个字段`[name: String, size: Integer]`的表模式的 `TableSource` 需要一个 `TypeInformation`，其中至少有两个字段名为 `name` 和 `size` ，类型为 `String` 和 `Integer`。 这可能是一个 `PojoTypeInfo` 或 `RowTypeInfo`，它有两个名为 `name` 和 `size` 的字段匹配类型。

However, some types, such as Tuple or CaseClass types, do support custom field names. If a `TableSource` returns a `DataStream` or `DataSet` of a type with fixed field names, it can implement the `DefinedFieldMapping` interface to map field names from the table schema to field names of the physical return type.

然而，有些类型，如 Tuple 或 CaseClass 类型，确实支持自定义字段名。如果 `TableSource` 返回具有固定字段名的类型的 `DataStream` 或 `DataSet`，它可以实现 `DefinedFieldMapping` 接口，将字段名从表模式映射到物理返回类型的字段名。

### Defining a BatchTableSource

### 定义一个 BatchTableSource

The `BatchTableSource` interface extends the `TableSource` interface and defines one additional method:

`BatchTableSource` 接口扩展了 `TableSource` 接口，并定义了一个额外的方法:



```
BatchTableSource<T> implements TableSource<T> {

  public DataSet<T> getDataSet(ExecutionEnvironment execEnv);
}
```





```
BatchTableSource[T] extends TableSource[T] {

  def getDataSet(execEnv: ExecutionEnvironment): DataSet[T]
}
```



*   `getDataSet(execEnv)`: Returns a `DataSet` with the data of the table. The type of the `DataSet` must be identical to the return type defined by the `TableSource.getReturnType()` method. The `DataSet` can by created using a regular [data source](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/batch/#data-sources) of the DataSet API. Commonly, a `BatchTableSource` is implemented by wrapping a `InputFormat` or [batch connector](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/batch/connectors.html).

*   `getDataSet(execEnv)`: 返回包含表数据的 `DataSet`。`DataSet` 的类型必须与 `TableSource.getReturnType()` 方法定义的返回类型相同。`DataSet` 可以通过使用 DataSet API 的常规[数据源](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/batch/#data-sources)创建。通常，`BatchTableSource` 是通过包装 `InputFormat` 或 [batch connector](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/batch/connectors.html)来实现的。

### Defining a StreamTableSource

### 定义一个 StreamTableSource

The `StreamTableSource` interface extends the `TableSource` interface and defines one additional method:

`StreamTableSource` 接口扩展了 `TableSource` 接口，并定义了一个额外的方法:



```
StreamTableSource<T> implements TableSource<T> {

  public DataStream<T> getDataStream(StreamExecutionEnvironment execEnv);
}
```





```
StreamTableSource[T] extends TableSource[T] {

  def getDataStream(execEnv: StreamExecutionEnvironment): DataStream[T]
}
```



*   `getDataStream(execEnv)`: Returns a `DataStream` with the data of the table. The type of the `DataStream` must be identical to the return type defined by the `TableSource.getReturnType()` method. The `DataStream` can by created using a regular [data source](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/datastream_api.html#data-sources) of the DataStream API. Commonly, a `StreamTableSource` is implemented by wrapping a `SourceFunction` or a [stream connector](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/connectors/).

*   `getDataStream(execEnv)`: 返回带有表数据的`DataStream`。`DataStream` 的类型必须与 `TableSource.getReturnType()` 方法定义的返回类型相同。`DataStream` 可以通过使用 DataStream API 的常规[数据源(data source)](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/datastream_api.html#data-sources)创建。通常，`StreamTableSource` 是通过包装 `SourceFunction` 或[流连接器(stream connector)](//ci.apache.org/projects/flink/flink-docs-release-1.7/dev/connectors/)来实现的。

### Defining a TableSource with Time Attributes

### 使用时间属性定义表源(TableSource)

Time-based operations of streaming [Table API](tableApi.html#group-windows) and [SQL](sql.html#group-windows) queries, such as windowed aggregations or joins, require explicitly specified [time attributes](streaming/time_attributes.html).

流式[表API](tableApi.html#group-windows)和[SQL](sql.html#group-windows)查询的基于时间的操作(如窗口聚合或连接)需要显式指定[时间属性](streaming/time_attributes.html)。

A `TableSource` defines a time attribute as a field of type `Types.SQL_TIMESTAMP` in its table schema. In contrast to all regular fields in the schema, a time attribute must not be matched to a physical field in the return type of the table source. Instead, a `TableSource` defines a time attribute by implementing a certain interface.

`TableSource` 在其表模式中将 time 属性定义为类型为 `Types.SQL_TIMESTAMP` 的字段。与模式中的所有常规字段相比，时间属性不能与表源返回类型中的物理字段匹配。相反，`TableSource`通过实现某个接口来定义时间属性。

#### Defining a Processing Time Attribute

#### 定义处理时间属性(Processing Time Attribute)

[Processing time attributes](streaming/time_attributes.html#processing-time) are commonly used in streaming queries. A processing time attribute returns the current wall-clock time of the operator that accesses it. A `TableSource` defines a processing time attribute by implementing the `DefinedProctimeAttribute` interface. The interface looks as follows:

[处理时间属性](streaming/time_attributes.html#processing-time)通常用于流查询。处理时间属性返回访问它的操作符的当前壁钟时间(wall-clock time)。`TableSource` 通过实现 `DefinedProctimeAttribute` 接口来定义处理时间属性。接口如下:



```
DefinedProctimeAttribute {

  public String getProctimeAttribute();
}
```





```
DefinedProctimeAttribute {

  def getProctimeAttribute: String
}
```



*   `getProctimeAttribute()`: Returns the name of the processing time attribute. The specified attribute must be defined of type `Types.SQL_TIMESTAMP` in the table schema and can be used in time-based operations. A `DefinedProctimeAttribute` table source can define no processing time attribute by returning `null`.

*   `getProctimeAttribute()`: 返回处理时间属性的名称。必须在表模式中定义指定的属性类型 `Types.SQL_TIMESTAMP`，并且可以在基于时间的操作中使用。`DefinedProctimeAttribute` 表源可以通过返回 `null` 来定义没有处理时间属性。

Attention Both `StreamTableSource` and `BatchTableSource` can implement `DefinedProctimeAttribute` and define a processing time attribute. In case of a `BatchTableSource` the processing time field is initialized with the current timestamp during the table scan.

注意 `StreamTableSource` 和 `BatchTableSource` 都可以实现 `DefinedProctimeAttribute` 并定义处理时间属性。对于 `BatchTableSource`，处理时间字段在表扫描期间使用当前时间戳初始化。

#### Defining a Rowtime Attribute

#### 定义 Rowtime 属性(Rowtime Attribute)

[Rowtime attributes](streaming/time_attributes.html#event-time) are attributes of type `TIMESTAMP` and handled in a unified way in stream and batch queries.

[Rowtime属性](streaming/time_attributes.html#event-time)是 `TIMESTAMP` 类型的属性，在流和批处理查询中以统一的方式处理。

A table schema field of type `SQL_TIMESTAMP` can be declared as rowtime attribute by specifying

通过指定，可以将类型为 `SQL_TIMESTAMP` 的表模式字段声明为 rowtime 属性

*   the name of the field,
*   字段名，
*   a `TimestampExtractor` that computes the actual value for the attribute (usually from one or more other fields), and
*   `TimestampExtractor` 计算属性的实际值(通常来自一个或多个其他字段)，以及
*   a `WatermarkStrategy` that specifies how watermarks are generated for the the rowtime attribute.
*   指定如何为 rowtim e属性生成水印的 `WatermarkStrategy`。

A `TableSource` defines a rowtime attribute by implementing the `DefinedRowtimeAttributes` interface. The interface looks as follows:

`TableSource` 通过实现 `DefinedRowtimeAttributes` 接口定义了一个 rowtime 属性。接口如下:



```
DefinedRowtimeAttribute {

  public List<RowtimeAttributeDescriptor> getRowtimeAttributeDescriptors();
}
```





```
DefinedRowtimeAttributes {

  def getRowtimeAttributeDescriptors: util.List[RowtimeAttributeDescriptor]
}
```



*   `getRowtimeAttributeDescriptors()`: Returns a list of `RowtimeAttributeDescriptor`. A `RowtimeAttributeDescriptor` describes a rowtime attribute with the following properties:
*   `getRowtimeAttributeDescriptors()`: 返回一个 `RowtimeAttributeDescriptor` 列表。`RowtimeAttributeDescriptor` 描述了一个具有以下属性的 rowtime 属性:
    *   `attributeName`: The name of the rowtime attribute in the table schema. The field must be defined with type `Types.SQL_TIMESTAMP`.
    *   `attributeName`: 表模式中 rowtime 属性的名称。必须使用类型 `Types.SQL_TIMESTAMP` 定义字段。
    *   `timestampExtractor`: The timestamp extractor extracts the timestamp from a record with the return type. For example, it can convert convert a Long field into a timestamp or parse a String-encoded timestamp. Flink comes with a set of built-in `TimestampExtractor` implementation for common use cases. It is also possible to provide a custom implementation.
    *   `timestampExtractor`: 时间戳提取器(timestamp extractor)从具有返回类型的记录中提取时间戳。例如，它可以将长字段转换为时间戳，或者解析字符串编码的时间戳。Flink 附带一组内置的 `TimestampExtractor` 实现，用于常见的用例。还可以提供自定义实现。
    *   `watermarkStrategy`: The watermark strategy defines how watermarks are generated for the rowtime attribute. Flink comes with a set of built-in `WatermarkStrategy` implementations for common use cases. It is also possible to provide a custom implementation.
    *   `watermarkStrategy`: 水印策略(watermark strategy)定义了如何为 rowtime 属性生成水印。Flink 为常见用例提供了一组内置的 `WatermarkStrategy` 实现。还可以提供自定义实现。

Attention Although the `getRowtimeAttributeDescriptors()` method returns a list of descriptors, only a single rowtime attribute is support at the moment. We plan to remove this restriction in the future and support tables with more than one rowtime attribute.

注意，虽然 `getRowtimeAttributeDescriptors()` 方法返回一个描述符列表，但目前只支持一个 rowtime 属性。我们计划在将来删除这个限制，并支持具有多个 rowtime 属性的表。

Attention Both, `StreamTableSource` and `BatchTableSource`, can implement `DefinedRowtimeAttributes` and define a rowtime attribute. In either case, the rowtime field is extracted using the `TimestampExtractor`. Hence, a `TableSource` that implements `StreamTableSource` and `BatchTableSource` and defines a rowtime attribute provides exactly the same data to streaming and batch queries.

请注意，`StreamTableSource` 和 `BatchTableSource` 都可以实现 `DefinedRowtimeAttributes` 并定义 rowtime 属性。在这两种情况下，行时间字段都是使用 `TimestampExtractor` 提取的。因此，实现 `StreamTableSource` 和 `BatchTableSource` 并定义 rowtime 属性的 `TableSource` 为流处理和批处理查询提供了完全相同的数据。

##### Provided Timestamp Extractors

##### 提供时间戳提取器(Timestamp Extractors)

Flink provides `TimestampExtractor` implementations for common use cases.

Flink 为常用用例提供了 `TimestampExtractor` 实现。

The following `TimestampExtractor` implementations are currently available:

以下 `TimestampExtractor` 实现目前可用:

*   `ExistingField(fieldName)`: Extracts the value of a rowtime attribute from an existing `LONG`, `SQL_TIMESTAMP`, or timestamp formatted `STRING` field. One example of such a string would be ‘2018-05-28 12:34:56.000’.
*   `ExistingField(fieldName)`: 从现有的 `LONG`, `SQL_TIMESTAMP` 或格式化的 `STRING` 字段中提取 rowtime 属性的值。这样一个字符串的一个例子是 ‘2018-05-28 12:34:56.000’。
*   `StreamRecordTimestamp()`: Extracts the value of a rowtime attribute from the timestamp of the `DataStream` `StreamRecord`. Note, this `TimestampExtractor` is not available for batch table sources.
*   `StreamRecordTimestamp()`: 从 `DataStream` `StreamRecord` 的时间戳中提取 rowtime 属性的值。注意，此 `TimestampExtractor` 不适用于批处理表源。

A custom `TimestampExtractor` can be defined by implementing the corresponding interface.

自定义的 `TimestampExtractor` 可以通过实现相应的接口来定义。

##### Provided Watermark Strategies

##### 提供水印策略(Watermark Strategies)

Flink provides `WatermarkStrategy` implementations for common use cases.

Flink 为常用用例提供了`水印策略(WatermarkStrategy)`实现。

The following `WatermarkStrategy` implementations are currently available:

目前提供以下 `WatermarkStrategy` 实现：

*   `AscendingTimestamps`: A watermark strategy for ascending timestamps. Records with timestamps that are out-of-order will be considered late.
*   `AscendingTimestamps`: 用于提升时间戳的水印策略。带有无序时间戳的记录将被视为迟到。
*   `BoundedOutOfOrderTimestamps(delay)`: A watermark strategy for timestamps that are at most out-of-order by the specified delay.
*   `BoundedOutOfOrderTimestamps(delay)`: 时间戳的水印策略，其最多在指定的延迟之外是无序的。
*   `PreserveWatermarks()`: A strategy which indicates the watermarks should be preserved from the underlying `DataStream`.
*   `PreserveWatermarks()`: 应该从底层的 `DataStream` 中保留指示水印的策略。

A custom `WatermarkStrategy` can be defined by implementing the corresponding interface.

可以通过实现相应的接口来定义自定义的 `WatermarkStrategy`。

### Defining a TableSource with Projection Push-Down

### 使用投影下推定义表源 Defining a TableSource with Projection Push-Down

A `TableSource` supports projection push-down by implementing the `ProjectableTableSource` interface. The interface defines a single method:

`TableSource` 通过实现 `ProjectableTableSource` 接口支持投影下推。该接口定义了一个单一的方法:



```
ProjectableTableSource<T> {

  public TableSource<T> projectFields(int[] fields);
}
```





```
ProjectableTableSource[T] {

  def projectFields(fields: Array[Int]): TableSource[T]
}
```



*   `projectFields(fields)`: Returns a _copy_ of the `TableSource` with adjusted physical return type. The `fields` parameter provides the indexes of the fields that must be provided by the `TableSource`. The indexes relate to the `TypeInformation` of the physical return type, _not_ to the logical table schema. The copied `TableSource` must adjust its return type and the returned `DataStream` or `DataSet`. The `TableSchema` of the copied `TableSource` must not be changed, i.e, it must be the same as the original `TableSource`. If the `TableSource` implements the `DefinedFieldMapping` interface, the field mapping must be adjusted to the new return type.

*   `projectFields(fields)`: 返回具有调整后的物理返回类型的 `TableSource` 的 _副本(copy)_。`fields` 参数提供了必须由 `TableSource` 提供的字段的索引。索引与物理返回类型的 `TypeInformation` 有关，而 _不是_ 与逻辑表模式相关。复制的 `TableSource` 必须调整其返回类型和返回的 `DataStream` 或 `DataSet`。复制的 `TableSource` 的 `TableSchema` 不能更改，即它必须与原来的 `TableSource` 相同。如果 `TableSource` 实现了 `DefinedFieldMapping` 接口，则必须将字段映射调整为新的返回类型。

The `ProjectableTableSource` adds support to project flat fields. If the `TableSource` defines a table with nested schema, it can implement the `NestedFieldsProjectableTableSource` to extend the projection to nested fields. The `NestedFieldsProjectableTableSource` is defined as follows:

`ProjectableTableSource` 为项目平面字段添加了支持。如果 `TableSource` 定义了一个带有嵌套模式的表，它可以实现 `NestedFieldsProjectableTableSource` 来将投影扩展到嵌套字段。`NestedFieldsProjectableTableSource` 的定义如下:



```
NestedFieldsProjectableTableSource<T> {

  public TableSource<T> projectNestedFields(int[] fields, String[][] nestedFields);
}
```





```
NestedFieldsProjectableTableSource[T] {

  def projectNestedFields(fields: Array[Int], nestedFields: Array[Array[String]]): TableSource[T]
}
```



*   `projectNestedField(fields, nestedFields)`: Returns a _copy_ of the `TableSource` with adjusted physical return type. Fields of the physical return type may be removed or reordered but their type must not be changed. The contract of this method is essentially the same as for the `ProjectableTableSource.projectFields()` method. In addition, the `nestedFields` parameter contains for each field index in the `fields` list, a list of paths to all nested fields that are accessed by the query. All other nested fields do not need to be read, parsed, and set in the records that are produced by the `TableSource`. **IMPORTANT** the types of the projected fields must not be changed but unused fields may be set to null or to a default value.

*   `projectNestedField(fields, nestedFields)`: 返回 `TableSource` 的具有调整后的物理返回类型的一个 _副本(copy)_。可以删除或重新排序物理返回类型的字段，但不能更改它们的类型。该方法的契约(contract)本质上与 `ProjectableTableSource.projectFields()` 方法相同。此外，`nestedFields` 参数包含 `fields` 列表中的每个字段索引，这是查询访问的所有嵌套字段的路径列表。所有其他嵌套字段都不需要在 `TableSource` 生成的记录中读取、解析和设置。**最重要的是** 不能更改投影字段的类型，但是可以将未使用的字段设置为null或默认值。

### Defining a TableSource with Filter Push-Down

### 使用下推过滤器定义表源(TableSource)

The `FilterableTableSource` interface adds support for filter push-down to a `TableSource`. A `TableSource` extending this interface is able to filter records such that the returned `DataStream` or `DataSet` returns fewer records.

`FilterableTableSource` 接口增加了对 `TableSource` 下推过滤器的支持。扩展这个接口的 `TableSource` 能够过滤记录，这样返回的 `DataStream` 或 `DataSet` 返回的记录就会更少。

The interface looks as follows:

接口如下:



```
FilterableTableSource<T> {

  public TableSource<T> applyPredicate(List<Expression> predicates);

  public boolean isFilterPushedDown();
}
```





```
FilterableTableSource[T] {

  def applyPredicate(predicates: java.util.List[Expression]): TableSource[T]

  def isFilterPushedDown: Boolean
}
```



*   `applyPredicate(predicates)`: Returns a _copy_ of the `TableSource` with added predicates. The `predicates` parameter is a mutable list of conjunctive predicates that are “offered” to the `TableSource`. The `TableSource` accepts to evaluate a predicate by removing it from the list. Predicates that are left in the list will be evaluated by a subsequent filter operator.
*   `applyPredicate(predicates)`: 返回带有添加谓词的 `TableSource` 的 _副本(copy)_。`predicates` 参数是一个可变的连接谓词列表，它们“提供(offered)”给 `TableSource`。`TableSource` 接受通过从列表中删除谓词来计算谓词的值。列表中剩下的谓词将由后续过滤器操作符计算。
*   `isFilterPushedDown()`: Returns true if the `applyPredicate()` method was called before. Hence, `isFilterPushedDown()` must return true for all `TableSource` instances returned from a `applyPredicate()` call.
*   `isFilterPushedDown()`: 如果之前调用了 `applyPredicate()` 方法，则返回 true。因此，对于从 `applyPredicate()` 调用返回的所有 `TableSource` 实例，`isFilterPushedDown()` 必须返回 true。

## Define a TableSink

## 定义一个 TableSink

A `TableSink` specifies how to emit a `Table` to an external system or location. The interface is generic such that it can support different storage locations and formats. There are different table sinks for batch tables and streaming tables.

`TableSink` 指定如何将 `Table` 发送到外部系统或位置。该接口是通用的，因此它可以支持不同的存储位置和格式。对于批处理表和流表，有不同的表接收器(table sinks)。

The general interface looks as follows:

通用接口如下:



```
TableSink<T> {

  public TypeInformation<T> getOutputType();

  public String[] getFieldNames();

  public TypeInformation[] getFieldTypes();

  public TableSink<T> configure(String[] fieldNames, TypeInformation[] fieldTypes);
}
```





```
TableSink[T] {

  def getOutputType: TypeInformation<T>

  def getFieldNames: Array[String]

  def getFieldTypes: Array[TypeInformation]

  def configure(fieldNames: Array[String], fieldTypes: Array[TypeInformation]): TableSink[T]
}
```



The `TableSink#configure` method is called to pass the schema of the Table (field names and types) to emit to the `TableSink`. The method must return a new instance of the TableSink which is configured to emit the provided Table schema.

调用 `TableSink#configure` 方法将表的模式(字段名和类型)传递给 `TableSink`。该方法必须返回 TableSink 的一个新实例，该实例被配置为发出所提供的表模式。

### BatchTableSink

### 批处理表接收器(BatchTableSink)

Defines an external `TableSink` to emit a batch table.

定义外部 `TableSink` 以发出批处理表。

The interface looks as follows:

接口如下：



```
BatchTableSink<T> implements TableSink<T> {

  public void emitDataSet(DataSet<T> dataSet);
}
```





```
BatchTableSink[T] extends TableSink[T] {

  def emitDataSet(dataSet: DataSet[T]): Unit
}
```



### AppendStreamTableSink

### 附加流表接收器(AppendStreamTableSink)

Defines an external `TableSink` to emit a streaming table with only insert changes.

定义一个外部 `TableSink` 来发出只包含插入更改的流表。

The interface looks as follows:

接口如下：



```
AppendStreamTableSink<T> implements TableSink<T> {

  public void emitDataStream(DataStream<T> dataStream);
}
```





```
AppendStreamTableSink[T] extends TableSink[T] {

  def emitDataStream(dataStream: DataStream<T>): Unit
}
```



If the table is also modified by update or delete changes, a `TableException` will be thrown.

如果表也被 update 或 delete 修改，则会抛出一个 `TableException`。

### RetractStreamTableSink

### 收回流表接收器(RetractStreamTableSink)

Defines an external `TableSink` to emit a streaming table with insert, update, and delete changes.

定义一个外部 `TableSink`，用于发出具有插入、更新和删除更改的流表。

The interface looks as follows:

接口如下：



```
RetractStreamTableSink<T> implements TableSink<Tuple2<Boolean, T>> {

  public TypeInformation<T> getRecordType();

  public void emitDataStream(DataStream<Tuple2<Boolean, T>> dataStream);
}
```





```
RetractStreamTableSink[T] extends TableSink[Tuple2[Boolean, T]] {

  def getRecordType: TypeInformation[T]

  def emitDataStream(dataStream: DataStream[Tuple2[Boolean, T]]): Unit
}
```



The table will be converted into a stream of accumulate and retraction messages which are encoded as Java `Tuple2`. The first field is a boolean flag to indicate the message type (`true` indicates insert, `false` indicates delete). The second field holds the record of the requested type `T`.

该表将被转换为一个累加和收回消息流，这些消息被编码为 Java `Tuple2`。第一个字段是一个布尔标志，用于指示消息类型(`true` 表示插入，`false` 表示删除)。第二个字段保存所请求类型 `T` 的记录。

### UpsertStreamTableSink

### 维护流表接收器(UpsertStreamTableSink)

Defines an external `TableSink` to emit a streaming table with insert, update, and delete changes.

定义一个外部 `TableSink`，用于发出具有插入、更新和删除更改的流表。

The interface looks as follows:

接口如下：



```
UpsertStreamTableSink<T> implements TableSink<Tuple2<Boolean, T>> {

  public void setKeyFields(String[] keys);

  public void setIsAppendOnly(boolean isAppendOnly);

  public TypeInformation<T> getRecordType();

  public void emitDataStream(DataStream<Tuple2<Boolean, T>> dataStream);
}
```





```
UpsertStreamTableSink[T] extends TableSink[Tuple2[Boolean, T]] {

  def setKeyFields(keys: Array[String]): Unit

  def setIsAppendOnly(isAppendOnly: Boolean): Unit

  def getRecordType: TypeInformation[T]

  def emitDataStream(dataStream: DataStream[Tuple2[Boolean, T]]): Unit
}
```



The table must be have unique key fields (atomic or composite) or be append-only. If the table does not have a unique key and is not append-only, a `TableException` will be thrown. The unique key of the table is configured by the `UpsertStreamTableSink#setKeyFields()` method.

该表必须具有唯一的 key 字段（原子或复合）或仅附加。如果表没有唯一 key 并且不是仅附加，则抛出 `TableException`。表的唯一键由 `UpsertStreamTableSink#setKeyFields()` 方法配置。

The table will be converted into a stream of upsert and delete messages which are encoded as a Java `Tuple2`. The first field is a boolean flag to indicate the message type. The second field holds the record of the requested type `T`.

该表将被转换为 upsert 和 delete 消息流，这些消息被编码为 Java `Tuple2`。第一个字段是一个布尔标志，用于指示消息类型。第二个字段保存所请求类型 `T` 的记录。

A message with true boolean field is an upsert message for the configured key. A message with false flag is a delete message for the configured key. If the table is append-only, all messages will have a true flag and must be interpreted as insertions.

具有 true 布尔字段的消息是已配置 key 的 upsert 消息。带有错误标志的消息是已配置 key 的删除消息。如果表是仅附加的，则所有消息都将具有 true 标志，并且必须解释为插入。

## Define a TableFactory

## 定义表工厂(TableFactory)

A `TableFactory` allows to create different table-related instances from string-based properties. All available factories are called for matching to the given set of properties and a corresponding factory class.

`TableFactory` 允许从基于字符串的属性创建不同的表相关实例。调用所有可用工厂以匹配给定的属性集和相应的工厂类。

Factories leverage Java’s [Service Provider Interfaces (SPI)](https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html) for discovering. This means that every dependency and JAR file should contain a file `org.apache.flink.table.factories.TableFactory` in the `META_INF/services` resource directory that lists all available table factories that it provides.

工厂利用 Java 的[服务提供者接口(Service Provider Interfaces, SPI)](https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html)进行发现。这意味着每个依赖项和 JAR 文件都应在 `META_INF/services` 资源目录中包含一个文件 `org.apache.flink.table.factories.TableFactory`，该文件列出了它提供的所有可用表工厂。

Every table factory needs to implement the following interface:

每个表工厂都需要实现以下接口：



```
package org.apache.flink.table.factories;

interface TableFactory {

  Map<String, String> requiredContext();

  List<String> supportedProperties();
}
```





```
package org.apache.flink.table.factories

trait TableFactory {

  def requiredContext(): util.Map[String, String]

  def supportedProperties(): util.List[String]
}
```



*   `requiredContext()`: Specifies the context that this factory has been implemented for. The framework guarantees to only match for this factory if the specified set of properties and values are met. Typical properties might be `connector.type`, `format.type`, or `update-mode`. Property keys such as `connector.property-version` and `format.property-version` are reserved for future backwards compatibility cases.
*   `requiredContext()`: 指定已为此工厂实现的上下文。如果满足指定的属性和值集，框架保证仅匹配此工厂。典型属性可能是 `connector.type`, `format.type` 或 `update-mode`。诸如 `connector.property-version` 和 `format.property-version` 之类的属性 keys 保留用于将来的向后兼容性情况。
*   `supportedProperties`: List of property keys that this factory can handle. This method will be used for validation. If a property is passed that this factory cannot handle, an exception will be thrown. The list must not contain the keys that are specified by the context.
*   `supportedProperties`: 此工厂可以处理的属性 keys 列表。此方法将用于验证。如果传递了该工厂无法处理的属性，则会抛出异常。该列表不得包含上下文指定的 keys。

In order to create a specific instance, a factory class can implement one or more interfaces provided in `org.apache.flink.table.factories`:

为了创建特定实例，工厂类可以实现 `org.apache.flink.table.factories` 中提供的一个或多个接口：

*   `BatchTableSourceFactory`: Creates a batch table source.
*   `BatchTableSourceFactory`: 创建批处理表源。
*   `BatchTableSinkFactory`: Creates a batch table sink.
*   `BatchTableSinkFactory`: 创建批处理表接收器。
*   `StreamTableSoureFactory`: Creates a stream table source.
*   `StreamTableSoureFactory`: 创建流表源。
*   `StreamTableSinkFactory`: Creates a stream table sink.
*   `StreamTableSinkFactory`: 创建流表接收器。
*   `DeserializationSchemaFactory`: Creates a deserialization schema format.
*   `DeserializationSchemaFactory`: 创建反序列化架构格式。
*   `SerializationSchemaFactory`: Creates a serialization schema format.
*   `SerializationSchemaFactory`: 创建序列化架构格式。

The discovery of a factory happens in multiple stages:

工厂的发现经历了多个阶段:

*   Discover all available factories.
*   发现所有可用的工厂。
*   Filter by factory class (e.g., `StreamTableSourceFactory`).
*   按工厂类过滤(例如，`StreamTableSourceFactory`)。
*   Filter by matching context.
*   通过匹配上下文过滤。
*   Filter by supported properties.
*   按支持的属性过滤。
*   Verify that exactly one factory matches, otherwise throw an `AmbiguousTableFactoryException` or `NoMatchingTableFactoryException`.
*   验证一个工厂是否匹配，否则抛出 `AmbiguousTableFactoryException` 或 `NoMatchingTableFactoryException`。

The following example shows how to provide a custom streaming source with an additional `connector.debug` property flag for parameterization.

以下示例显示如何为参数化提供附加 `connector.debug` 属性标志的自定义流式源。



```
import org.apache.flink.table.sources.StreamTableSource;
import org.apache.flink.types.Row;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class MySystemTableSourceFactory implements StreamTableSourceFactory<Row> {

  @Override
  public Map<String, String> requiredContext() {
    Map<String, String> context = new HashMap<>();
    context.put("update-mode", "append");
    context.put("connector.type", "my-system");
    return context;
  }

  @Override
  public List<String> supportedProperties() {
    List<String> list = new ArrayList<>();
    list.add("connector.debug");
    return list;
  }

  @Override
  public StreamTableSource<Row> createStreamTableSource(Map<String, String> properties) {
    boolean isDebug = Boolean.valueOf(properties.get("connector.debug"));

    # additional validation of the passed properties can also happen here

    return new MySystemAppendTableSource(isDebug);
  }
}
```





```
import java.util
import org.apache.flink.table.sources.StreamTableSource
import org.apache.flink.types.Row

class MySystemTableSourceFactory extends StreamTableSourceFactory[Row] {

  override def requiredContext(): util.Map[String, String] = {
    val context = new util.HashMap[String, String]()
    context.put("update-mode", "append")
    context.put("connector.type", "my-system")
    context
  }

  override def supportedProperties(): util.List[String] = {
    val properties = new util.ArrayList[String]()
    properties.add("connector.debug")
    properties
  }

  override def createStreamTableSource(properties: util.Map[String, String]): StreamTableSource[Row] = {
    val isDebug = java.lang.Boolean.valueOf(properties.get("connector.debug"))

    # additional validation of the passed properties can also happen here

    new MySystemAppendTableSource(isDebug)
  }
}
```



### Use a TableFactory in the SQL Client

### 在 SQL 客户端中使用 TableFactory

In a SQL Client environment file, the previously presented factory could be declared as:

在 SQL 客户端环境文件中，先前显示的工厂可以声明为：



```
tables:
 - name: MySystemTable
   type: source
   update-mode: append
   connector:
     type: my-system
     debug: true
```



The YAML file is translated into flattened string properties and a table factory is called with those properties that describe the connection to the external system:

YAML 文件被转换为扁平的(flattened)字符串属性，并使用描述与外部系统的连接的属性调用表工厂：



```
update-mode=append
connector.type=my-system
connector.debug=true
```



Attention Properties such as `tables.#.name` or `tables.#.type` are SQL Client specifics and are not passed to any factory. The `type` property decides, depending on the execution environment, whether a `BatchTableSourceFactory`/`StreamTableSourceFactory` (for `source`), a `BatchTableSinkFactory`/`StreamTableSinkFactory` (for `sink`), or both (for `both`) need to discovered.

注意，属性如 `tables.#.name` 或 `tables.#.type` 是 SQL 客户端的特定类型，不传递给任何工厂。`type` 属性根据执行环境决定是否需要发现 `BatchTableSourceFactory`/`StreamTableSourceFactory` (用于`source`)、`BatchTableSinkFactory`/`StreamTableSinkFactory`(用于 `sink`)或两者(用于 `both`)。

### Use a TableFactory in the Table & SQL API

### 在 Table 和 SQL API 中使用 TableFactory

For a type-safe, programmatic approach with explanatory Scaladoc/Javadoc, the Table & SQL API offers descriptors in `org.apache.flink.table.descriptors` that translate into string-based properties. See the [built-in descriptors](connect.html) for sources, sinks, and formats as a reference.

对于具有解释性 Scaladoc/Javadoc 的类型安全的编程方法，Table 和 SQL API 在 `org.apache.flink.table.descriptors` 中提供了转换为基于字符串的属性的描述符。有关源(sources)，接收器(sinks)和格式(formats)的信息，请参阅[内置描述符(built-in descriptors)](connect.html)作为参考。

A connector for `MySystem` in our example can extend `ConnectorDescriptor` as shown below:

在我们的示例中，`MySystem` 的连接器可以扩展 `ConnectorDescriptor`，如下所示：



```
import org.apache.flink.table.descriptors.ConnectorDescriptor;
import java.util.HashMap;
import java.util.Map;

/**
  * Connector to MySystem with debug mode.
  */
public class MySystemConnector extends ConnectorDescriptor {

  public final boolean isDebug;

  public MySystemConnector(boolean isDebug) {
    super("my-system", 1, false);
    this.isDebug = isDebug;
  }

  @Override
  protected Map<String, String> toConnectorProperties() {
    Map<String, String> properties = new HashMap<>();
    properties.put("connector.debug", Boolean.toString(isDebug));
    return properties;
  }
}
```





```
import org.apache.flink.table.descriptors.ConnectorDescriptor
import java.util.HashMap
import java.util.Map

/**
  * Connector to MySystem with debug mode.
  */
class MySystemConnector(isDebug: Boolean) extends ConnectorDescriptor("my-system", 1, false) {

  override protected def toConnectorProperties(): Map[String, String] = {
    val properties = new HashMap[String, String]
    properties.put("connector.debug", isDebug.toString)
    properties
  }
}
```



The descriptor can then be used in the API as follows:

然后可以在 API 中使用描述符，如下所示：



```
StreamTableEnvironment tableEnv = // ...

tableEnv
  .connect(new MySystemConnector(true))
  .inAppendMode()
  .registerTableSource("MySystemTable");
```





```
val tableEnv: StreamTableEnvironment = // ...
tableEnv
  .connect(new MySystemConnector(isDebug = true))
  .inAppendMode()
  .registerTableSource("MySystemTable")
```
